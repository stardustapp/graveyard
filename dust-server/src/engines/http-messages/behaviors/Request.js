GraphEngine.attachBehavior('http-messages/v1-beta1', 'Request', {

      /*
      TODO: getters?
        RemoteAddress: req.connection.remoteAddress, // TODO: X-Forwarded-For
        HostName: hostname || ipv4 || ipv6,
        AltPort: altPort.length ? parseInt(altPort) : null,
        Origin: `http://${hostname || ipv4 || ipv6}${altPort.length ? ':' : ''}${altPort}`,
      */

  makeStringResponse(contentType, StringData, statusCode=200) {
    return this.RETURNED.newResponse({
      Timestamp: new Date,
      Status: { Code: statusCode },
      Headers: [{
        Key: 'Content-Type',
        Value: contentType,
      }],
      Body: { StringData },
    });
  },

  makeJsonResponse(data, statusCode=200) {
    return this.makeStringResponse('application/json', JSON.stringify(data, null, 2), statusCode);
  },

  makeHtmlResponse(data, statusCode=200) {
    return this.makeStringResponse('text/html', data, statusCode);
  },

  async makeRedirect(target, statusCode=303) {
    const resp = await this.makeHtmlResponse(commonTags.safeHtml`
      <!doctype html>
      <title>Redirecting...</title>
      <p>You are being redirected to <a href="${target}">${target}</a>.</p>
    `, statusCode);
    resp.setHeader('Location', target);
    return resp;
  },

  // for browsers
  makeBlobResponse(blob, statusCode=200) {
    // For text files, assume UTF-8
    let type = blob.Mime || 'application/octet-stream';
    if (type.startsWith('text/') && !type.includes('charset=')) {
      type += '; charset=utf-8';
    }
    // TODO: some sort of prefab for this
    return this.RETURNED.newResponse({
      Timestamp: new Date,
      Status: { Code: statusCode },
      Headers: [{
        Key: 'Content-Type',
        Value: type,
      }],
      Body: { Base64: blob.Data },
    });
  },

  // NodeJS read streams
  // TODO!!!
  sendStream(stream, mimeType='application/octet-stream') {
    this.addHeader('Content-Type', mimeType);
    const handler = this.buildResponseHeader(200);

    stream.once('error', err => {
      console.log('http send stream error:', err.message);
      try {
        this.sendJson({error: err.name, message: err.message}, 500);
      } catch (err) {
        console.log('http encountered new error reporting stream error', err.stack);
        handler.write(JSON.stringify({error: err.name, message: err.message}));
        handler.finish();
      }
    });
    handler.writeStream(stream);
  },

  async respondWithFolderIndex(target) {
    const html = commonTags.safeHtml`<!doctype html>
<title>${target.Name}</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
  body { background-color: #ddd; }
  footer { color: #333; }
  footer p { margin: 0; }
</style>
<h1>${target.Name}/</h1>
<p><a href="..">Navigate up</a></p>
<hr>
<ul>
`+`\n  `+target.Children.map(c => {
  const dirChar = c.Type === 'Folder' ? '/' : '';
  return commonTags.safeHtml`
  <li><a href="${c.Name}${dirChar}">${c.Name}</a>${dirChar}</li>
`}).join('\n  ')+`\n`+commonTags.safeHtml`</ul>
<hr>
<footer>
  <p>Generated by <a href="https://github.com/stardustapp/dust-server">dust-server</a></p>
  <p>Served as ${'TODO'}</p>
  <p>Powered by the Stardust platform</p>
</footer>`;
    return await this.respondWithString(html, 'text/html');
  },

});
