class HttpServer {
  constructor(domainManager, hostLoader) {
    this.domainManager = domainManager;
    this.wsc = new WSC.WebApplication({
      host: '0.0.0.0',
      handlers: [
        [/^.+$/, HttpWildcardHandler.bind(null, this)],
      ],
    });

    this.hostLoaders = new Map;
    this.hostLoaderFactory = hostLoader;
  }

  addRoute(regex, handler) {
    this.wsc.handlers.splice(-1, 0, [regex, handler]);
    this.wsc.handlersMatch.splice(-1, 0, [new RegExp(regex), handler]);
  }

  startServer(port=9237) {
    this.wsc.port = port;
    this.wsc.start();
    console.log('http server listening on %s', this.wsc.port);
  }

  /*async*/ getVHost(hostname) {
    if (this.hostLoaders.has(hostname)) {
      return this.hostLoaders.get(hostname);
    }
    const loader = this.hostLoaderFactory(hostname).catch(err => {
      console.log('Failed to load vhost', hostname, err);
      this.hostLoaders.delete(hostname);
      return null;
    });;
    this.hostLoaders.set(hostname, loader);
    return loader;
  }
}

class VirtualHost {
  constructor(hostname, webEnv) {
    this.hostname = hostname;
    this.webEnv = webEnv;
  }

  async handleGET(req, responder) {
    const [reqPath, queryStr] = (req.uri || '/').split('?');

    let target;

    // If it's a directory, try filling entry with index.html
    if (reqPath.endsWith('/')) {
      const indexEntry = await this.webEnv.getEntry(reqPath+'index.html');
      if (indexEntry && indexEntry.get) {
        target = await indexEntry.get();
      }
    }

    // If we don't have a target yet just get it directly
    if (!target) {
      const entry = await this.webEnv.getEntry(reqPath);
      if (!entry || (!entry.get && !entry.invoke)) {

        // Maybe it's a directory instead of a file?
        if (!reqPath.endsWith('/')) {
          const dEntry = await this.webEnv.getEntry(reqPath + '/');
          if (dEntry && dEntry.get) {
            let newUrl = reqPath + '/';
            if (req.uri.includes('?'))
              newUrl += '?' + queryStr;
            return responder.redirectTo(newUrl);
          }
        }

        return responder.sendJson({error: 'not-found'}, 404);
      }

      if (entry.get) {
        target = await entry.get();
      } else if (entry.invoke) {
        target = await entry.invoke(new StringLiteral('request', JSON.stringify(req)));
      }
    }

    if (!target) {
      return responder.sendJson({error: 'null-target'}, 500);

    } else if (target.Type === 'Blob') {
      responder.sendBlob(target);

    } else if (target.Type === 'Folder' && target.Name === 'http response') {
      // allows dynamic content to change based on the request
      responder.sendStarResponse(target);

    } else if (target.Type === 'Folder') {

      const html = commonTags.safeHtml`<!doctype html>
<title>${target.Name}</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style type="text/css">
  body { background-color: #ddd; }
  footer { color: #333; }
  footer p { margin: 0; }
</style>
<h1>${target.Name}/</h1>
<p><a href="..">Navigate up</a></p>
<hr>
<ul>
`+`\n  `+target.Children.map(c => {
  const dirChar = c.Type === 'Folder' ? '/' : '';
  return commonTags.safeHtml`
  <li><a href="${c.Name}${dirChar}">${c.Name}</a>${dirChar}</li>
`}).join('\n  ')+`\n`+commonTags.safeHtml`</ul>
<hr>
<footer>
  <p>Generated by <a href="https://github.com/stardustapp/chrome-profile-server">${HttpServer.SERVER_HEADER}</a></p>
  <p>Served as ${this.webEnv.baseUri}</p>
  <p>Powered by the Stardust platform</p>
</footer>`;
      responder.sendHtml(html);

    } else {
      responder.sendJson(target);
    }
  }

  // Specifically for routing POST to function invocations
  // Not very forgiving, since POSTs generally come from ourself
  async handlePOST(req, responder) {
    const [reqPath, queryStr] = (req.uri || '/').split('?');

    const entry = await this.webEnv.getEntry(reqPath);
    if (!entry) {
      return responder.sendJson({error: 'not-found'}, 404);
    }
    if (!entry.invoke) {
      const allowed = [];
      if (entry.get) allowed.push('GET');
      if (entry.get) allowed.push('HEAD');
      responder.addHeader('Allow', allowed.join(', '));
      return responder.sendJson({error: 'post-not-allowed'}, 405);
    }
    const response = await entry.invoke(new StringLiteral('request', JSON.stringify(req)));

    if (!response) {
      return responder.sendJson({error: 'null-response'}, 500);
    } else if (response.Type === 'Blob') {
      responder.sendBlob(response);
    } else if (response.Type === 'Folder' && response.Name === 'http response') {
      // allows submission receivers to do things like redirect and set cookies
      responder.sendStarResponse(response);
    } else {
      responder.sendJson(response);
    }
  }
}

HttpServer.SERVER_HEADER = 'Chrome-'
  +chrome.runtime.getManifest().short_name+'/'
  +chrome.runtime.getManifest().version;


class Responder {
  constructor(handler) {
    this.handler = handler;
    this.statusCode = null;
  }

  addHeader(key, val) {
    this.handler.setHeader(key, val);
  }

  emitResponse(statusCode, payload) {
    if (this.statusCode != null) {
      throw new Error(`App tried to send additional HTTP responses`);
    }
    const {handler} = this;
    handler.statusCode = statusCode;

    handler.responseLength = payload.length || payload.byteLength;
    handler.setHeader('Date', moment.utc().format('ddd, DD MMM YYYY HH:mm:ss [GMT]'));
    handler.setHeader('Server', HttpServer.SERVER_HEADER);
    handler.writeHeaders(statusCode);
    handler.write(payload);
    handler.finish();
  }

   // Helpers

  sendJson(data, status=200) {
    this.addHeader('Content-Type', 'application/json');
    this.emitResponse(status, JSON.stringify(data, null, 2));
  }

  sendHtml(data, status=200) {
    this.addHeader('Content-Type', 'text/html');
    this.emitResponse(status, data);
  }

  sendBlob(blob, status=200) {
    // For text files, assume UTF-8
    let type = blob.Mime || 'application/octet-stream';
    if (type.startsWith('text/') && !type.includes('charset=')) {
      type += '; charset=utf-8';
    }
    this.addHeader('Content-Type', type);

    // write the bytes of the string to an ArrayBuffer
    const decoded = atob(blob.Data);
    var ab = new ArrayBuffer(decoded.length);
    var ia = new Uint8Array(ab);
    for (var i = 0; i < decoded.length; i++) {
        ia[i] = decoded.charCodeAt(i);
    }
    this.emitResponse(status, ab);
  }

  redirectTo(target, status=303) {
    this.addHeader('Location', target);
    this.emitResponse(status, commonTags.safeHtml`<!doctype html>
<title>Redirecting...</title>
<p>You are being redirected to <a href="${target}">${target}</a>.</p>`);
  }

  sendStarResponse(resp) {
    let statusCode = 200;
    let headers = [];
    let body = null;
    resp.Children.forEach(c => {
      switch (c.Name) {
        case 'status code':
          statusCode = parseInt(c.StringValue);
          break;
        case 'headers':
          headers = c.Children;
          break;
        case 'body':
          body = c;
          break;
      }
    });
    if (!body) {
      throw new Error(`sendStarResponse() didn't see a 'body' in the given response`);
    }

    // write it!
    for (const header of headers) {
      this.addHeader(header.Name, header.StringValue);
    }
    this.sendBlob(body, statusCode);
  }
}

class HttpWildcardHandler extends WSC.BaseHandler {
  constructor(httpServer) {
    super();
    this.httpServer = httpServer;
  }

  tcpInfo() {
    return new Promise(r => chrome.sockets.tcp.getInfo(
            this.request.connection.stream.sockId, r));
  }

  async get() {
    const {headers, uri, method} = this.request;
    const {localAddress, localPort, peerAddress, peerPort} = this.tcpInfo();

    await this.routeRequest({
      method, uri, headers,
      queryParams: this.request.arguments || {},
      ip: {localAddress, localPort, peerAddress, peerPort},
    });
  }

  async post() {
    const {headers, uri, method, body, bodyparams} = this.request;
    const {localAddress, localPort, peerAddress, peerPort} = this.tcpInfo();

    await this.routeRequest({
      method, uri, headers, body, bodyparams,
      queryParams: this.request.arguments || {},
      ip: {localAddress, localPort, peerAddress, peerPort},
    });
  }

  async routeRequest(meta) {
    const responder = new Responder(this);
    const {headers, method, uri} = meta;

    try {
      if (!headers.host) {
        console.log(`${method} //${headers.host}${uri}`, 400);
        return responder.sendJson({
          success: false,
          error: 'bad-request',
          message: 'Your browser sent a request that this server could not understand.',
          cause: 'The "Host" HTTP header is required.',
        }, 400);
      }

      const hostMatch = headers.host.match(
  /^(?:([0-9]{1,3}(?:\.[0-9]{1,3}){3})|\[([0-9a-f:]+(?:[0-9]{1,3}(?:\.[0-9]{1,3}){3})?)\]|((?:[a-z0-9_.-]+\.)?[a-z]+))(?::(\d+))?$/i);
      if (!hostMatch) {
        console.log(`${method} //${headers.host}${uri}`, 400);
        return responder.sendJson({
          success: false,
          error: 'bad-request',
          message: 'Your browser sent a request that this server could not understand.',
          cause: 'The "Host" HTTP header could not be parsed. If your request is reasonable, please file a bug.',
        }, 400);
      }
      const [_, ipv4, ipv6, hostname, port] = hostMatch;

      let domain = hostname;
      // Treat raw IPs as localhost
      if (ipv4 || ipv6)
        domain = 'localhost';

      if (domain) {
        const vhost = await this.httpServer.getVHost(domain);
        if (vhost) {
          return await vhost[`handle${method}`](meta, responder);
        }
      }

      console.log(`${method} //${headers.host}${uri}`, 421);
      return responder.sendJson({
        success: false,
        error: 'domain-not-found',
        message: `Misdirected Request: The website you tried to access doesn't exist here`,
        cause: `This server doesn't have a domain configured with a website for the hostname ${domain}. If this is your domain, go ahead and claim it from within your personal dashboard.`,
      }, 421);

    } catch (err) {
      console.log(`${method} //${headers.host}${uri}`, 500, err);
      return responder.sendJson({
        success: false,
        error: 'internal-error',
        message: `The server failed to respond`,
        cause: `${err.name}: ${err.message}`,
      }, 500);
      throw err;
    }
  }
}
